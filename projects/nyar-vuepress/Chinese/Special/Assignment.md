Assignment 都是带副作用的操作.

## 类型

类型是一门语言的灵魂.

有了强大的类型系统, IDE 会变得非常的聪明, 就像和你心有灵犀一样.

## 绑定

```ts
a = 1
```

这个声明实际上干了两件事, 声明一个类型, 并且给符号 `a` 绑定一个值:

虽然我有时候也口癖喜欢叫赋值, 但实际上确实是把值绑定到了符号上.

所以下文如果出现赋值那也表达绑定含义, `alias 赋值 绑定` .

```ts
type a Integer|Fraction|Float
var a 1
```

如果你已经声明了类型, 那么就不能绑定到一个不兼容类型的值上.

```ts
a::String
❌a = 1
```

解释器会优先计算右边的值, 然后将其类型绑定到左边的符号.

但是对于整数并不会绑定到 `Integer` , 而是会绑定到 `Number` .

因为对于 `a::Integer` 而言 `a = a/2` 是非法表达式, 但这又确实是很常用的操作.

如果你确定自己不会犯傻的话可以预先声明 `a::Integer32` , 这样的程序通常是高效的.

每个中缀式**赋值符号**都对应一个前缀式**关键词**

- `=` 的前缀式是 `var` 
- `::` 的前缀式是 `type` 

## 重绑定

当你首次声明了一个值以后, 其类型就被确定了, 无法重新赋值给**不兼容类型**.

```ts
a = 1

✔️a = 2
❌a = ""
✔️a @= ""
```

如果就是要改变其类型, 那么可以使用 `::` 重新声明类型, 然后重新赋值.

或者用 `@=` 重绑定值.

- `@=` 的前缀式是 `let` 

```ts
a @= ""
let a ""
```

::: tip
注意你不能在一个语句里连续声明绑定.

因为这种情况是有歧义的, 编译器和解释器懒得猜你到底想干嘛.

```ts
❌x = y = 1
✔️(x = y) = 1
✔️x = (y = 1)
```

:::

## 常量

有时候你想要声明不会被改变的量, 也就是所谓的常量, 那么你可以用 `#=` .

```ts
pi #= 3.14159
❌pi = 4
```

你无法用 `=` 或 `@=` 改变符号的值, `::` 改变类型也无效.

唯一的方法是用 `remove` 直接移除符号, 然后声明新的值.

```ts
remove(pi)
✔️pi = 4
```

- `#=` 的前缀式是 `const` 

```ts
type pi Float
const pi 4
```

::: tip
 `remove` 真是个有趣的"函数", `remove(remove)` 会怎么样呢...

可惜 `remove` 不会被移除, 因为 `remove` 是函数保留词, 保留词都不会被移除, 也无法增加新属性.

或者说 `remove` 是用起来像是个函数的关键词, 类似的还有 `print` , 实际上是个关键词但是用函数写法.

而且移除也只是从当前命名空间中去掉, 并不能直接抹除符号的定义.
:::

## 元组

 `%` 是个垃圾箱, 什么都可以往里扔


## 转移

https://kaisery.github.io/trpl-zh-cn/ch04-01-what-is-ownership.html

```ts
a=1
b&=a
❌a
✔️b
```
