# Assignment

## 绑定

```ts
let a = 1
var a = 1
const a = 1

```

这个声明实际上干了两件事, 声明一个类型, 并且给符号 `a` 绑定一个值:

虽然我有时候也口癖喜欢叫赋值, 但实际上确实是把值绑定到了符号上.

直接省略 var


---

Assignment 都是带副作用的操作.

每个中缀式**赋值符号**都对应一个前缀式**关键词**

- `=` 的前缀式是 `var`
- `@=` 的前缀式是 `let`

类型

为什么不写一起...

因为容易让人当场去世

我认为程序的必要逻辑与辅助信息应该分开

虽然不禁止 `a::Number = 1` 这种写法, 但我还是希望能分开写.


所以下文如果出现赋值那也表达绑定含义, `alias 赋值 绑定` .

```ts
type a Integer|Fraction|Float
var a 1
```

如果你已经声明了类型, 那么就不能绑定到一个不兼容类型的值上.

```ts
a::String
❌a = 1
```

解释器会优先计算右边的值, 然后将其类型绑定到左边的符号.

但是对于整数并不会绑定到 `Integer` , 而是会绑定到 `Number` .

因为对于 `a::Integer` 而言 `a = a/2` 是非法表达式, 但这又确实是很常用的操作.

如果你确定自己不会犯傻的话可以预先声明 `a::Integer32` , 这样的程序通常是高效的.

## 元组

 `%` 是个垃圾箱, 什么都可以往里扔

::: tip
注意你不能在一个语句里连续声明绑定.

因为这种情况是有歧义的, 编译器和解释器懒得猜你到底想干嘛.

```ts
❌x = y = 1
✔️(x = y) = 1
✔️x = (y = 1)
```

:::

## 重绑定

当你首次声明了一个值以后, 其类型就被确定了, 无法重新赋值给**不兼容类型**.

```ts
a = 1

✔️a = 2
❌a = ""

✔️a @= ""
✔️let a ""
```

如果就是要改变其类型, 那么可以使用 `::` 重新声明类型, 然后重新赋值.

或者用 `@=` 重绑定值.

## 常量

有时候你想要声明不会被改变的量, 也就是所谓的常量, 那么你可以用 `#=` .

```ts
pi #= 3.14159
❌pi = 4
```

你无法用 `=` 或 `@=` 改变符号的值, `::` 改变类型也无效.

唯一的方法是用 `remove` 直接移除符号, 然后声明新的值.

```ts
remove(pi)
✔️pi = 4
```

- `#=` 的前缀式是 `const`

```ts
type pi Float
const pi 4
```

::: tip
 `remove` 真是个有趣的"函数", `remove(remove)` 会怎么样呢...

问这个问题的, 你是魔鬼吗......

可惜 `remove` 不会被移除, 因为 `remove` 是函数保留词, 保留词都不会被移除, 也无法增加新属性.

或者说 `remove` 是用起来像是个函数的关键词, 类似的还有 `print` , 实际上是个关键词但是用函数写法.

而且移除也只是从当前命名空间中去掉, 并不能直接抹除符号的定义.
:::

## 自返

在别的语言中可能有 `a+=1` 这样的简便写法, 但是 Nyar 中只能写 `a = a + 1` .

虽然这写着繁琐, 但是 Nyar 语言中的运算符如此之多...

只对 `+ -` 特殊处理不大公平吧, `* /` 呢, 甚至还有 `^^ × ⊗` 这些的行为如何确定呢?

为了一致性考虑只能一棍子打死全都不允许自返写法了.

你可能会问: 这岂不是额外造成了开销, 这不会影响执行效率吗?

我对你的疑惑表示理解, 但我只能说, 请相信编译器.

## 转移

下面是一些非常复杂的东西, 事实上你不用懂这些也能快乐编程.

但是要写出超高效的程序不得不学习一些底层的东西, 这些东西可不那么快乐.

https://kaisery.github.io/trpl-zh-cn/ch04-01-what-is-ownership.html

```ts
a=1
b&=a
❌a
✔️b
```

